#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"

////////////////////////
#include "smile.h"

#include "images/hamster.h"
#include "images/square.h"
#include "images/sunglasses.h"

/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START_INIT,
  START,
  LEVEL_INIT,
  LEVEL,
  ENTER,
  PLAY_INIT,
  PLAY,
  WIN_INIT,
  WIN,
  LOSE_INIT,
  LOSE,
};


struct sprite player;

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state

  initializePlayer(&player);

  // enum gba_state state = WIN_INIT;
  enum gba_state state = START_INIT;

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    // drawFullScreenImageDMA(smile);

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    waitForVBlank();
    switch (state) {
      case START_INIT: 
        initializePlayer(&player);
  
        drawGrid();
        drawString(20, 25, "WELCOME TO ADITI'S HAMSTER HIKE", WHITE);
        drawString(40, 60, "PRESS ENTER TO START", WHITE);
        
        drawImageDMA(60, 75, 90, 90, square);

        state = START;

        break;

      case START:
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = LEVEL_INIT;
        }
        break;

      case LEVEL_INIT: 
        drawGrid();
        drawRectDMA(42, 82, 81, 56, RED);
        
        drawString(20, 85, "SELECT LEVEL", WHITE);

        drawString(55, 100, "A: EASY", WHITE);
        drawString(75, 100, "B: HARD", WHITE);

        
        drawString(135, 42, "press BACKSPACE to restart", WHITE);
        
          state = LEVEL;
        break;

      case LEVEL:
        if((KEY_JUST_PRESSED(BUTTON_A, currentButtons, previousButtons))) {
          player.maxClicks = 40;

          drawRectDMA(70, 92, 60, 20, RED);
          drawString(75, 100, "B: HARD", WHITE);


          drawRectDMA(50, 92, 60, 20, WHITE);
          drawString(55, 100, "A: EASY", RED);

          drawRectDMA(110, 50, 140, 20, RED);
          drawString(115, 60, "press ENTER to start", WHITE);

          state = ENTER;
        }

        if((KEY_JUST_PRESSED(BUTTON_B, currentButtons, previousButtons))) {
          player.maxClicks = 25;

          drawRectDMA(50, 92, 60, 20, RED);
          drawString(55, 100, "A: EASY", WHITE);

          drawRectDMA(70, 92, 60, 20, WHITE);
          drawString(75, 100, "B: HARD", RED);

          drawRectDMA(110, 50, 140, 20, RED);
          drawString(115, 60, "press ENTER to start", WHITE);

          state = ENTER;
        }

        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START_INIT;
        }

        break; 

      case ENTER:
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = PLAY_INIT;
        }

        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START_INIT;
        }

        break;

      case PLAY_INIT:
        drawGrid();
        drawMap();

  //       char scoreArr[15];
  // sprintf(scoreArr, "SCORE:%d", player.clicks);
  // drawString(140, 15, scoreArr, BLUE);
        
        drawRectDMA(10, 160, 70, 10, RED);
        if (player.maxClicks == 25) {
          drawString(12, 162, "LEVEL: HARD", BLUE);
        }
        if (player.maxClicks == 40) {
          drawString(12, 162, "LEVEL: EASY", BLUE);
        }
        
        

        drawString(142, 80, "press BACKSPACE to restart", WHITE);
        
        state = PLAY;
        break;

      case PLAY:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START_INIT;
        }

        // erase path
        drawRectDMA(player.row, player.col, player.length, player.length, WHITE);

        // button logic
        // up button
        if (KEY_DOWN(BUTTON_UP, currentButtons)) {
          player.row -= 1;
          if (KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons)) {
            player.clicks += 1;
          }
          
        }
        // down button
        if (KEY_DOWN(BUTTON_DOWN, currentButtons)) {
          player.row += 1;
          if (KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons)) {
            player.clicks += 1;
          }
        }
        // right button
        if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
          player.col += 1;
          if (KEY_JUST_PRESSED(BUTTON_RIGHT, currentButtons, previousButtons)) {
            player.clicks += 1;
          }
        }
        // left button
        if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
          player.col -= 1;
          if (KEY_JUST_PRESSED(BUTTON_LEFT, currentButtons, previousButtons)) {
            player.clicks += 1;
          }
        }

        // win and lose conditions
        // win condition
        if (player.row >= 90 && player.row <= 100 && player.col == WIDTH) {
          state = WIN_INIT;
          break;
        }
        // lose condition
        if (wallCollision(player)) {
          state = LOSE_INIT;
          break;
        }

        if (player.clicks > player.maxClicks) {
          state = LOSE_INIT;
          break;
        }

        // score
        // clickCounter(currentButtons);
        clickCounter();


        // redraw conditions
        drawRectDMA(player.row, player.col, player.length, player.length, RED);
        break;

      case WIN_INIT:
        drawFullScreenImageDMA(hamster); 

        drawString(15, 100, "YAYY!!", BLACK);
        drawString(95, 50, "YOU", WHITE);
        drawString(85, 125, "WIN!", WHITE);

        drawString(145, 40, "press BACKSPACE to restart", WHITE);

        state = WIN;
        break;
        
      case WIN:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START_INIT;
        }
        break;

      case LOSE_INIT:
        drawFullScreenImageDMA(sunglasses);

        drawString(20, 100, "BOOO!!", WHITE);
        drawString(75, 80, "YOU", WHITE);
        drawString(75, 129, "LOSE!", WHITE);

        drawString(140, 40, "press BACKSPACE to restart", WHITE);

        state = LOSE;
        break;

      case LOSE:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START_INIT;
        }   
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  // UNUSED(previousButtons); // You can remove this once previousButtons is used


  return 0;
}

void initializePlayer(struct sprite *player) {
  player->row = 13;
  player->col = 13;
  player->length = 3;
  player->velRow = 2;
  player->velCol = 2;
  player->clicks = 0;
  player->maxClicks = 0;
}

void clickCounter(void) {
  drawRectDMA(135, 10, 60, 15, RED);

  char scoreArr[15];
  sprintf(scoreArr, "SCORE:%d", player.clicks);
  drawString(140, 15, scoreArr, BLUE);
}

int wallCollision(struct sprite p) {
  return 
    (0 <= p.row && p.row <= 160 && 0 <= p.col && p.col <= 10) || 
    (20 <= p.row && p.row <= 160 && 10 <= p.col && p.col <= 20) || 
    (20 <= p.row && p.row <= 70 && 20 <= p.col && p.col <= 30) || 
    (100 <= p.row && p.row <= 160 && 20 <= p.col && p.col <= 140) || 
    (0 <= p.row && p.row <= 10 && 10 <= p.col && p.col <= 240) || 
    (10 <= p.row && p.row <= 80 && 40 <= p.col && p.col <= 50) || 
    (80 <= p.row && p.row <= 90 && 30 <= p.col && p.col <= 90) || 
    (30 <= p.row && p.row <= 70 && 60 <= p.col && p.col <= 70) || 
    (50 <= p.row && p.row <= 80 && 80 <= p.col && p.col <= 90) || 
    (30 <= p.row && p.row <= 40 && 70 <= p.col && p.col <= 100) || 
    (30 <= p.row && p.row <= 100 && 100 <= p.col && p.col <= 140) || 
    (10 <= p.row && p.row <= 20 && 50 <= p.col && p.col <= 240) || 
    (20 <= p.row && p.row <= 120 && 150 <= p.col && p.col <= 160) || 
    (0 <= p.row && p.row <= 0 && 0 <= p.col && p.col <= 0) || 
    (130 <= p.row && p.row <= 160 && 140 <= p.col && p.col <= 240) || 
    (20 <= p.row && p.row <= 60 && 160 <= p.col && p.col <= 240) || 
    (70 <= p.row && p.row <= 80 && 170 <= p.col && p.col <= 200) || 
    (90 <= p.row && p.row <= 120 && 160 <= p.col && p.col <= 180) || 
    (80 <= p.row && p.row <= 130 && 190 <= p.col && p.col <= 200) || 
    (60 <= p.row && p.row <= 80 && 210 <= p.col && p.col <= 240) || 
    (100 <= p.row && p.row <= 120 && 200 <= p.col && p.col <= 240);
}

void drawGrid(void) {
  fillScreenDMA(BLUE);
  drawRectDMA(0, 10, 1, HEIGHT, RED);
  drawRectDMA(0, 20, 1, HEIGHT, RED);
  drawRectDMA(0, 30, 1, HEIGHT, RED);
  drawRectDMA(0, 40, 1, HEIGHT, RED);
  drawRectDMA(0, 50, 1, HEIGHT, RED);
  drawRectDMA(0, 60, 1, HEIGHT, RED);
  drawRectDMA(0, 70, 1, HEIGHT, RED);
  drawRectDMA(0, 80, 1, HEIGHT, RED);
  drawRectDMA(0, 90, 1, HEIGHT, RED);
  drawRectDMA(0, 100, 1, HEIGHT, RED);
  drawRectDMA(0, 110, 1, HEIGHT, RED);
  drawRectDMA(0, 120, 1, HEIGHT, RED);
  drawRectDMA(0, 130, 1, HEIGHT, RED);
  drawRectDMA(0, 140, 1, HEIGHT, RED);
  drawRectDMA(0, 150, 1, HEIGHT, RED);
  drawRectDMA(0, 160, 1, HEIGHT, RED);
  drawRectDMA(0, 170, 1, HEIGHT, RED);
  drawRectDMA(0, 180, 1, HEIGHT, RED);
  drawRectDMA(0, 190, 1, HEIGHT, RED);
  drawRectDMA(0, 200, 1, HEIGHT, RED);
  drawRectDMA(0, 210, 1, HEIGHT, RED);
  drawRectDMA(0, 220, 1, HEIGHT, RED);
  drawRectDMA(0, 230, 1, HEIGHT, RED);

  drawRectDMA(10, 0, WIDTH, 1, RED);
  drawRectDMA(20, 0, WIDTH, 1, RED);
  drawRectDMA(30, 0, WIDTH, 1, RED);
  drawRectDMA(40, 0, WIDTH, 1, RED);
  drawRectDMA(50, 0, WIDTH, 1, RED);
  drawRectDMA(60, 0, WIDTH, 1, RED);
  drawRectDMA(70, 0, WIDTH, 1, RED);
  drawRectDMA(80, 0, WIDTH, 1, RED);
  drawRectDMA(90, 0, WIDTH, 1, RED);
  drawRectDMA(100, 0, WIDTH, 1, RED);
  drawRectDMA(110, 0, WIDTH, 1, RED);
  drawRectDMA(120, 0, WIDTH, 1, RED);
  drawRectDMA(130, 0, WIDTH, 1, RED);
  drawRectDMA(140, 0, WIDTH, 1, RED);
  drawRectDMA(150, 0, WIDTH, 1, RED);

}

void drawMap(void) {
  // draw path
  // void drawRectDMA(int row, int col, int width, int height, volatile u16 color);
  drawRectDMA(10, 10, 30, 10, WHITE);
  drawRectDMA(20, 30, 10, 50, WHITE);
  drawRectDMA(70, 20, 20, 10, WHITE);
  drawRectDMA(80, 20, 10, 20, WHITE);
  drawRectDMA(90, 30, 70, 10, WHITE);
  drawRectDMA(40, 90, 10, 50, WHITE);
  drawRectDMA(40, 80, 10, 10, WHITE);
  drawRectDMA(40, 70, 10, 40, WHITE);
  drawRectDMA(70, 60, 10, 10, WHITE);
  drawRectDMA(30, 50, 10, 50, WHITE);
  drawRectDMA(20, 50, 70, 10, WHITE);
  drawRectDMA(20, 50, 90, 10, WHITE);
  drawRectDMA(20, 140, 10, 100, WHITE);
  drawRectDMA(120, 140, 40, 10, WHITE);
  drawRectDMA(80, 180, 10, 50, WHITE);
  drawRectDMA(80, 160, 30, 10, WHITE);
  drawRectDMA(60, 160, 10, 20, WHITE);
  drawRectDMA(60, 170, 40, 10, WHITE);
  drawRectDMA(70, 200, 10, 30, WHITE);
  drawRectDMA(90, 210, 30, 10, WHITE);

  drawString(2, 10, "START", WHITE);
  drawString(102, 202, "FINISH", WHITE);
}



